[
    
        
            {
                "ref": "https://freenice12.github.io/post/misunderstanding-over-the-tdd/",
                "title": "Misunderstanding over the TDD",
                "section": "post",
                "date" : "2021.04.20",
                "body": "TDD 오해 - 1  TDD 하는 사람들은 모든 기능을 구현할 때 TDD를(만) 이용해서 구현한다.\n 많은 분이 이야기하듯 모든 기능에 TDD를 사용할 필요는 없습니다. 물론 가능은 하겠지만, 시간이나 에너지의 낭비가 될 수 있습니다. 예를 들어 데이터베이스에 저장이 잘 되는지 HTTP 호출은 잘 되는지 등 굳이 테스트하지 않아도 되는 부분이 존재하기 마련입니다. 혹은 HTML에서 내가 그리게 될 요소가 잘 그려지는지, 어느 위치에 그려지는지 등은 꼭 TDD를 통해 작성하지 않아도 직접 테스트해 결과를 확인할 수 있고 피드백도 빠르게 받을 수 있습니다.\nTDD는 내가 구현해야 하는 기능 중 논리에 관한 영역과 내가 생각한 설계를 시험해보고 그 결과를 빠르게 피드백 받는 방법이라고 생각합니다. 따라서 모든 것의 시작을 테스트로 잡지 않아도 충분히 TDD를 한다고 할 수 있습니다(이는 두 번째 오해로 이어짐).\n덧붙여, 테스트가 모두 코드를 통해 수행된다는 강박을 가지지 않아도 될 것 같습니다.\nTDD 오해 - 2  TDD는 테스트를 먼저 작성해야만 TDD!\n 회사에서 우연히 동료와 TDD에\u001d 관한 이야길 나누는데 동료는 TDD의 제1 정의(젤 먼저 말 해서?;;)를 테스트를 먼저 작성한다.라고 생각하고 있었습니다. 시작부터 테스트 작성의 선후를 이야기해서 즉시 피드백을 줬습니다.\n제 생각에 테스트가 먼저냐 아니냐는 TDD에서 가장 중요한 가치도, 꼭 논해야 하는 명제도 아니라고 생각합니다. 우리가 최종적으로 보게 될 코드는 일종의 스냅샷으로 테스트를 먼저 작성했는지 하지 않았는지 알 수 있는 방법이 잘(거의?) 없습니다. 물론 그 과정은 상당히 중요합니다.\n테스트를 작성하면서 실패하는 동시에 문제점을 피드백 받고 성공하는 동시에 다음 작업을 생각할 신호를 뇌에 입력받게 되는 일련의 흐름이라고 볼 수 있습니다. 그리고 성공한 테스트들은 우리에게 안정감을 줍니다. 익숙하다면 테스트를 작성하는 과정에서 지루함도 얻을 수 있습니다. 하루하루 똥줄 타고 마음이 심숭생숭한 코드를 배치하느니 지루함과 안정감을 얻는 쪽을 택하는 편이 여가를 알차게 보낼 수 있는 방법이 아닐까 합니다.\n그리고 테스트 먼저란 말에서 먼저의 기준은 무엇입니까? 무엇보다 먼저 해야 테스트를 먼저 작성하는 건가요? 운영 코드?\nTDD by example이란 책을 보면 마치 테스트 코드를 먼저 작성하는 듯한, 그리고 테스트 코드를 먼저 작성하는 흐름을 읽을 수 있는데, 이는 아주 커다란 착각(내가 착각 하는 건가\u0026hellip;?)입니다. 여기까지 읽고 TDD by example에서도 \u0026ldquo;테스트를 먼저 작성하라\u0026quot;는 말이 있는데 무슨 헛소리냐고 하시는 분들이 있다면 다시 한번 책 내용을 떠올려 보시는 건 어떨까요? (저는 기억이 잘 안 나지만 다시 읽진 않\u0026hellip;)\n제가 읽은 내용을 떠올려보면, 책에서 무엇보다 가장 먼저 한 건 생각입니다. 즉 무슨 일(해야 할 일)을 어떻게 해야 할지 미리 생각해보고 이를 통해 어떤 코드를 작성할지 예측해 봤던 거죠. 그리고 난 후에야 테스트 코드를 작성하고 비로소 실패하는 피드백을 받기 시작합니다(말 장난 인가\u0026hellip;?).\n위 내용을 통해 짐작해 보면 역시 TDD는 설계를 테스트하는 방법이다.라는 말이 와닿기 시작합니다. 테스트 코드를 통해 최대한 작은 코드를 유지하고 원하는 기능은 모두 갖추는 등 좋은 점이 많이 있습니다. 다만, TDD를 한다고 해서 반드시 좋은 설계를 갖는 것은 아닙니다. 예를 들어, 테스트할 주요 대상 외 필요한 개체들을 모의(Mock)로 작성해 테스트 코드를 작성한다면 불필요한 추상화 등이 이뤄질 수 있습니다. 이는 적당히 경계하면서 진행해야 할 요소입니다.\n잡담 현재 저는 TypeScript라는 구전으로만 들어오던 언어를 사용해 화면을 구성해보고 있습니다. TDD를 사용해 작성하려 하고 있고, 원하는 기능은 테스트를 통한 피드백을 받고 천천히 개발하고 있습니다. 하지만 문제는 테스트한 코드와 실제 작동의 괴리에서 옵니다. 물론 저도 초보이고 매우 간단한 화면을 구성하고 있기 때문에 큰 문제는 아직 일어나지 않았습니다.\n예를 들어, 테스트 코드에선 잘 작동했고 원하는 기능을 잘 수행하는데 실제 프로젝트를 확인해보면 가끔 엉뚱한 결과가 나오는 경우입니다. 잘못된 점을 다시 생각해보면 테스트가 잘못 작성(엄한 테스트 코드를 덕지덕지 작성해두기)되었거나 테스트를 통해 미닫이문을 만들어 놓고 실제로는 문 앞뒤로 벽을 생성해둔 경우같이 코드 배치가 잘못된 느낌의 구성을 한 경우였던 것 같습니다.\n끝 TDD를 오랜 시간 해온 분들처럼 글을 쓰거나 읽으면서 틀린 생각을 빠르게 피드백 받아 TDD에 관한 더 깊은 내용과 실제 예제를 들고 다시 찾아올 수 있었으면 좋겠습니다.\n 그리고 젤 중요한: \u0026ldquo;항상 목적이 무엇인지 생각하자!\u0026rdquo;\n "
            }
        
    ,
        
            {
                "ref": "https://freenice12.github.io/post/test-jest-typescript-with-babel/",
                "title": "제스트에서 타입스크립트 테스트 하기(with babel)",
                "section": "post",
                "date" : "2021.04.16",
                "body": "타입스크립트 테스트하기 준비 $ yarn add --dev jest $ yarn add --dev babel-jest @babel/core @babel/preset-env @babel/preset-typescript @types/jest 타입스크립트를 jest로 테스트 할때 TypeScript를 사용하기 위해서는 ES6+ 하위 호환 및 ts -\u0026gt; js 변환을 위한 babel이란 녀석이 꼭 필요하다고 합니다.\n과정  TypeScript를 사용하는 프로젝트인데 jest를 사용하고 싶었다. import부터 제대로 되지 않는다\u0026hellip;\n 프론트에서도 테스트를 사용해 내가 원하는 기능은 먼저 테스트해 보고, 화면을 그리는 UI나에게는 매우 어려운 작업은 눈으로 테스트해 보려고 했습니다. 그런데 처음부터 만나게 된 import를 할 수 없다는 오류 메시지..\n먼저 위 준비과정의 jest, typescript, babel(너는 왜? ㅠㅠ)을 설치해주고, 다음으로 관련 설정들을 설정 파일을 통해 작성합니다(아래 설정 파일들은 프로젝트 루트에 생성).\n package.json  \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;jest\u0026#34;, },  jest.config.js  module.exports = { preset: \u0026#39;ts-jest\u0026#39;, testEnvironment: \u0026#39;node\u0026#39;, transform: { \u0026#34;\\\\.[jt]sx?$\u0026#34;: \u0026#34;babel-jest\u0026#34; }, }  babel.config.js  module.exports = { presets: [ [\u0026#39;@babel/preset-env\u0026#39;, {targets: {node: \u0026#39;current\u0026#39;}}], \u0026#39;@babel/preset-typescript\u0026#39; ], } 그럼 설정은 모두 마쳤고 실제로 테스트가 잘 작동하는지 봅니다. 이런 설정들을 추가한 이유는 ts 파일에서 import를 사용해 테스트하는 경우 import를 해석하지 못하고 오류를 발생시키기 때문이었습니다.\n 먼저 finally.test.js, finallyEx.ts 파일 생성  finally는 원하시는 이름으로 변경할 수 있지만 test.js로 끝나게 해주세요. finallyEx는 import해서 사용할 모듈입니다.   아래 내용을 작성하고 테스트를 실행합니다.  // finally.test.js import * as finallyEx from \u0026#39;./finallyEx\u0026#39;; test(\u0026#34;import datasetSupporter and use function\u0026#34;, () =\u0026gt; { const actual = finallyEx.add(1, 2) expect(actual).toBe(3) }) // finallyEx.ts export function add(a: number, b: number) { return a + b } 이제 테스트를 실행하면 짜장! 드디어 import를 사용해 테스트를 진행할 수 있게 되었습니다.\n테스트를 수정할 때마다 매번 확인하기 귀찮다면 --watch를 이용해보세요. 굉장히 편리합니다.\n$ yarn test # or $ yarn test --watch 테스트 코드를 작성하지 않아도 설정을 먼저 해두면 언젠가 써먹지 않을까요?!\n안녕~!\n"
            }
        
    ,
        
            {
                "ref": "https://freenice12.github.io/post/deprecated-implicit-conversion/",
                "title": "Deprecated Implicit Conversion",
                "section": "post",
                "date" : "2021.04.12",
                "body": "스칼라의 Implicit 마법과 작별 준비 스칼라에서 implicit, implicitly가 저 같은 입문자를 괴롭힌다는 소식을 접했지만 이내 Scala 3에서는 사용하지 않아도 충분한 대안이 마련되었다고 합니다. 대안은 다음 글에 작성하도록 하겠습니다(아직은 몰라요).\n그럼 implicit이 사라지기 전에 가볍게 한 번 보고 지나가겠습니다.\n예제 스칼라를 더 나은 자바로 사용하기 위해서 아래와 같은 코드를 사용했습니다. 이 예제 하나를 위해서는 그럭저럭 작성할 만한 코드같습니다.\n먼저 아래 코드를 보시죠.\n입장 case class Point(x: Int, y: Int) @tailrec def sumP(xs: List[Point], acc: Point = Point(0, 0)): Point = xs match { case h :: t =\u0026gt; sumP(t, Point(acc.x + h.x, acc.y + h.y)) case _ =\u0026gt; acc } sumP(List(Point(1, 2), Point(3, 4))) // Point(4, 6) 멋져 보이는 코드를 작성했습니다. 하지만\u0026hellip; 우리의 목표 implicit을 위해~!\n그럼 새로운 trait을 만들어 위에서 사용할 시작 값(Point(0, 0))과 각 값을 합하는 작업을 추상화해보겠습니다.\ntrait HapHae[A] { def init: A def hap(x: A, y: A): A } def hapHaeRa[A](xs: List[A])(hapHae: HapHae[A]): A = xs.foldLeft(hapHae.init)(hapHae.hap) // init과 hap을 사용하기 위해 foldLeft(for 문과 비슷)로 변경! 새로운 합을 할 수 있도록 합해!(HapHae)라는 trait을 통해 거부할 수 없는 명령어 합해라!(hapHaeRa) 함수를 작성했습니다. init이라는 초깃값을 가져야 하고 hap이라는 함수를 구현해야만 잘 동작합니다.\n그럼 이 HapHae는 어떻게 써먹을까요?\nval pointHapHae = new HapHae[Point] { override def init: Point = Point(0, 0) override def hap(x: Point, y: Point): Point = Point(x.x + y.x, x.y + y.y) } hapHaeRa(List(Point(4, 2), Point(3, 4)))(pointHapHae) // // Point(7, 6) 짜잔~!\n위 코드에서 보듯 초깃값과 합 함수를 구현한 새로운 HapHae를 생성했습니다. 거부할 수 없는 명령 합해라!(haeHaeRa)를 통해 결과를 잘 얻어올 수 있었습니다.\n절정  implicit은 Deprecated 되었습니다. Scala 3에서 대안이 소개됩니다. 다음(다음다음 다음?!) 글에서 이 대안을 (골고루~ 골고루~)다루도록 하겠습니다!\n 하지만 뭔가 마음에 들지 않습니다. 뒤에 꼬리처럼 붙는 pointHapHae가 거슬리기 시작합니다. 그래서 이를 없앨 수 있는 implicit 마법을 준비해 봤습니다. 간단히 키워드(implicit)를 더해주기만 하면 됩니다. 임시 다형성을 통해서 이를 해결해 보겠습니다.\n 임시 다형성(ad-hoc polymorphism)은 타입 파라미터를 이용해 암시적 인스턴스를 주입받아 사용하는 방법입니다.\n 이번에는 사람(Person)을 합해보도록 하겠습니다.\ncase class Person(name: String, age: Int) implicit val personHapHae = new HapHae[Person] { // \u0026lt;--------- 여기  override def init: Person = Person(\u0026#34;\u0026#34;, 0) override def hap(x: Person, y: Person): Person = Person(x.name + y.name, x.age + y.age) } // ...  def hapHaeRa[A](xs: List[A])(implicit hapHae: HapHae[A]): A = ... // \u0026lt;--------- 여기  // 사용 hapHaeRa(List(Person(\u0026#34;Hello + \u0026#34;, 30), Person(\u0026#34;Scala\u0026#34;, 40))) // Person(Hello + Scala, 70) hapHaeRa의 꼬리 personHapHae가 사라졌지만, 코드는 컴파일되고 정상 작동합니다. implicit을 사용해서 귀찮은 꼬리 하나를 뗴는 마법을 부려봤습니다.\n계속 이야기했지만 곧 사라질 예정이긴 하지만 어딘가엔 기존 코드에 남아있을\u0026hellip; 혹은 다른 프레임워크 등에 산재해 있을 implicit을 이해하는 데 도움이 되었으면 좋겠습니다.\n결론  implicit은 알아두되 사용은 자제하고 대안으로 소개된 Scala 3 에서의 방법을 사용하자!\n "
            }
        
    ,
        
            {
                "ref": "https://freenice12.github.io/post/brief-fp-in-scala-2/",
                "title": "스칼라로 본 Functional Programming(FP) - 2",
                "section": "post",
                "date" : "2021.04.09",
                "body": "스칼라로 본 Functional Programming(FP) - 2 Cats와 함께하는 FP (Cats 문서 내용을 토대로 내용을 전개합니다.) Type classes  이전 글에서 Monoid를 이런게 있구나 하고 훑어보았습니다. 이번에는 Functor를 훑어보겠습니다.\n Functor  Functor is a type class that abstracts over type constructors that can be map‘ed over. Examples of such type constructors are List, Option, and Future.\n 펑터는 map이 가능한 타입 생성자를 추상화하는 type class 입니다. Monoid에서도 봤듯 type class란 어떤 행위를 할 수 있는지 미리 정해놓은 모음(일단은\u0026hellip;)이라고 봐도 좋습니다.\n먼저, 캣츠 Functor 코드를 보겠습니다.\ntrait Functor[F[_]] { // F[_] 는 어떤 타입을 가지고 있는 효과라고 읽겠습니다.  def map[A, B](fa: F[A])(f: A =\u0026gt; B): F[B] } A 타입의 값을 가진 F(\u0026ldquo;effect\u0026rdquo; 또는 \u0026ldquo;computational context\u0026rdquo; 라고 부름)효과와 A 타입을 B 타입으로 바꾸는 함수를 받고, B 타입의 값을 갖는 F 효과를 반환합니다. 이게 코드를 봐도 뭘 본건지 잘 이해햐기 어렵기 때문에(추상화 어려움 ㅠㅠ) 바로 구현된 코드로 이해를 돕고있습니다.\nimplicit val functorForOption: Functor[Option] = new Functor[Option] { def map[A, B](fa: Option[A])(f: A =\u0026gt; B): Option[B] = fa match { case None =\u0026gt; None case Some(a) =\u0026gt; Some(f(a)) } } /* A =\u0026gt; B 는 String =\u0026gt; int 로 생각할 수 있고 convert 라는 메소드 이름(위에선 f)으로 나타낼 수 있습니다. public int convert(String input) { if (input.equals(\u0026#34;one\u0026#34;)) return 1; return -1; } 물론 convert 자체는 나쁜 예. */ 구현은 접어두고 다시 정의한 것을 보면 map[A, B](fa: Option[A])(f: A =\u0026gt; B): Option[B] 이고, F[A] 와 f를 확인하실 수 있습니다. 이에 더해 다른 관점으로 lift 라는 함수도 있는데 코드로 보겠습니다.\ntrait Functor[F[_]] { def map[A, B](fa: F[A])(f: A =\u0026gt; B): F[B] def lift[A, B](f: A =\u0026gt; B): F[A] =\u0026gt; F[B] = fa =\u0026gt; map(fa)(f) } 리프트 함수는 f: A =\u0026gt; B를 F[A] =\u0026gt; F[B]로 승격 시키는 코드입니다. 어디선가 언젠가 써먹겠죠? 꼭 다음번 포스트에서 이를 사용하는 실 세계(real-world) 예제를 작성해 보겠습니다.\nFunctors compose F 효과가 중첩된 경우(ex: F[G[_]])에 펑터의 합성을 통해 해결할 수 있습니다. 아래 코드를 보겠습니다.\nval listOption = List(Some(1), None, Some(2)) Functor[List].compose[Option].map(listOption)(_ + 1) // res1: List[Option[Int]] = List(Some(2), None, Some(3)) listOption 은 List(효과)에 Option(효과)이 중첩되어 있습니다. 이를 컴포즈를 통해 해결한 예인데요. 마지막 결과(res1)를 보면 리스트 효과(F) 내의 각 효과(G)에 함수(_ + 1)가 적용된 것을 확인하실 수 있습니다. 이처럼 펑터에는 효과의 중첩을 효과적으로 다룰 장치도 이미 마련되어 있습니다. 캣츠에는 더 간단하고 직관적으로 알수 있도록 Nested라는 data type을 제공하고 있습니다. 이 Nested를 이용한 코드는 조금 더 간결해지고 읽기 쉬워집니다(익숙하면).\nval nested: Nested[List, Option, Int] = Nested(listOption) // nested: Nested[List, Option, Int] = Nested(List(Some(1), None, Some(2)))  nested.map(_ + 1) 위 두 예제는 같은 값을 결과로 반환합니다.\nFunctor는 F[A](A 타입을 가지는 효과)에서 A 타입의 값을 f(A =\u0026gt; B) 함수를 이용해 B타입의 값을 가지는 효과로 변환하는 map과 f(A =\u0026gt; B) 함수를 F[A] 를 인자로 받아 F[B]를 반환하는 함수로 변환하는 lift를 가지고 있습니다.\n그럼 다음 글에서는 Monad(모나드)를 가지고 살포시 이야기 해보겠습니다.\n(.. 뭐라는거지?ㅠㅠ)\n"
            }
        
    ,
        
            {
                "ref": "https://freenice12.github.io/post/brief-fp-in-scala-1/",
                "title": "스칼라로 본 Functional Programming(FP) - 1",
                "section": "post",
                "date" : "2021.04.08",
                "body": "스칼라로 본 Functional Programming(FP) - 1 서론 FP라는 개념을 알게되고 실제로 프로그래밍 하기 전까지 왜 어려웠는지 생각해보니 바로 \u0026lsquo;FP 개념에 나오는 여러 typeclass 들이 정리가 안돼서\u0026rsquo;가 아니라 이런거 몰라도 일단 코딩해보는 닥코 느낌을 못 가져가서 그렇다고 깨닫게 되었습니다. 그러나 역시 기초는 뭐가 있는지는 알아야 하기에 간략하게 Monoid, Functor, Monad 라는게 이런 것이구나 하고 스윽 넘어가보도록 하겠습니다. 덧붙이자면 저에게도 FP는 생소합니다. 배우면서 정리하고 있습니다.\n많은 책들이 행위의 정의 및 코드로 구현 즉 typeclass를 열심히 설명 해줍니다. 언젠가는 이것들이 왜 그리고 언제 필요한지. 이것들을 통한 실 세계(real-world)의 예제를 가지고 꼭 포스팅을 해보도록 하겠습니다. 여러분도 많이 들어보셨을 바로 그! 이야기!\n Talk is cheap. Show me the \u0026hellip; code!\n Cats와 함께하는 FP (Cats 문서 내용을 토대로 내용을 전개합니다.) Typeclass \u0026amp; Datatypes  Cats에 보면 큰 분류로 Type classes 와 Data types가 있습니다. 각각에 대해서 소개를 보겠습니다.\n Type classes(문서 내용)  Type classes are a powerful tool used in functional programming to enable ad-hoc polymorphism, more commonly known as overloading. Where many object-oriented languages leverage subtyping for polymorphic code, functional programming tends towards a combination of parametric polymorphism (think type parameters, like Java generics) and ad-hoc polymorphism.\n 타입 클래스는 FP에서 임시(ad-hoc) 다형성(polymorphism, 오버로딩으로 더 잘 알려짐)을 가능하게 하는 강력한 도구입니다(임시 다형성은 다른 글에서도 소개됩니다). 많은 개채 지향 언어의 다형적 코드에 대한 subtyping을 활용하는데, FP는 파라미터를 이용한 다형성(자바 제네릭같은 타입 파라미터를 생각해보세요)과 임시(ad-hoc) 다형성 조합을 지향합니다.\nData types(문서 내용)  Type class가 다형성 및 ad-hoc 다형성의 조합을 정의하면 이 정의를 토대로 우리가 실제로 프로그래밍 할 때 사용할 타입(구현)을 Data type이라고 부릅니다.\n 앞으로 자주 볼 데이터 타입에는\u0026hellip;\n OptionT EitherT FunctionK 등이 있다고 합니다. 데이터 타입을 사용하는 예제와 실 세계 예제들은 곧(진짜?) 포스팅 할 수 있(을까?)도록 하겠습니다.  Type classes Monoid - 드디어 모노이드 잔말 말고 코드를 보겠습니다.\ndef sumInts(list: List[Int]): Int = list.foldRight(0)(_ + _) def concatStrings(list: List[String]): String = list.foldRight(\u0026#34;\u0026#34;)(_ ++ _) def unionSets[A](list: List[Set[A]]): Set[A] = list.foldRight(Set.empty[A])(_ union _) 구현부의 공통점이 보이시나요?\n바로, foldRight를 썻다는 점입니다. 그럼 foldRight은 어떤 함수일까요? 바로, 초기값(0, \u0026quot;\u0026quot;, Set.empty[A])을 인자로 받고 그 다음 함수((_ + _), (_ ++ _), _ union _)를 받고 있습니다. 두 번째 인자의 공통점은 _(underscore)가 2개인 함수라는 점입니다.\n왠지 타입을 뭉뚱그려주면(= 특정하지 않으면 = 일반화 하면 = java\u0026hellip; generic???) 타입에 구애받지 않고 사용할 수 있(을것 같다고 합니다)습니다. \u0026ldquo;다 더하기\u0026rdquo; trait을 만들어 보겠습니다.\ntrait AllPlus[A] { // 이름 실화? 다 더하기? -_-;;  def initValue: A // 빈 초기값  def allPlus(x: A, y: A): A // 인자 2개 함수 } 멋진 이름의 trait이 추출 되었습니다. 위에서 정의한 인터페이스로 먼저 sumInts 함수에서 사용할 수 있도록 구현해보면\u0026hellip;\nval intAdditionMonoid: AllPlus[Int] = new AllPlus[Int] { def initValue: Int = 0 def allPlus(x: Int, y: Int): Int = x + y } 짜잔~! 새로운 AllPlus 타입이 탄생했습니다. 이제 위에서 정의한 인터페이스와 그를 구현한 타입을 사용할 함수를 작성해 보겠습니다.\ndef neoPlusAll[A](list: List[A], ap: AllPlus[A]): A = list.foldRight(ap.initValue)(ap.allPlus) 이제 newPlusAll 을 통해서 타입에 구애받지 않고 String, Set 등도 모두모두 \u0026ldquo;다 더하기\u0026quot;할 수 있게 되었습니다. 종종 듣는(듣기 싫은) 모노이드(Monoid)가 바로 위 AllPlus trait 입니다.\n 모노이드로 전환:  \u0026ldquo;AllPlus\u0026rdquo; =\u0026gt; Monoid \u0026ldquo;initValue\u0026rdquo; =\u0026gt; empty \u0026ldquo;allPlus\u0026rdquo; =\u0026gt; combine    이렇게 이름을 바꾸면 완전한(남들이 말하는!) 모노이드가 됩니다.\n실제 캣츠에서 모노이드의 정의를 보고 마무리 하겠습니다. 세미 그룹을 확장하고 거기에 empty를 추가해 정의되어 있습니다.\ntrait Semigroup[A] { def combine(x: A, y: A): A } trait Monoid[A] extends Semigroup[A] { def empty: A } 캣츠에서는 모노이드를 SemiGroup(combine)의 조합과 확장(empty)을 통해 표현하는데 이런건 천천히 알아봐도 되고 일단 모노이드는 이런거구나 하고 넘어가도록 하겠습니다. 왜냐면 우리는 나중에 이걸 어디서 어떻게 써먹을지에 관심이 더 있기 때문입니다(나중에 잘 알게되면 수정해야 할 내용일지도\u0026hellip;).\n"
            }
        
    ,
        
            {
                "ref": "https://freenice12.github.io/post/total-function/",
                "title": "Total Function",
                "section": "post",
                "date" : "2021.04.04",
                "body": "완전 함수 - Scala With Cats library 먼저 제가 좋아하는 분 중 한 분인 케븬 님은 이렇게 조언해 주셨습니다.\n \u0026ldquo;캣츠 라이브러리 사용 전 먼저 해보면 좋은 작업 중 하나는 일반 함수를 완전 함수(Total Function)로 만드는 작업입니다.\u0026rdquo;\n 저는 아래와 같은 계획으로 코딩을 해보려고 했습니다.\n 자바처럼 스칼라 코드 작성하기 라이브러리(캣츠 이팩트) 사용하기  그런데 위 내용을 토대로 해서 순서를 수정하면,\n 자바처럼 스칼라 코드 작성하기  완전 함수로 작성하기   라이브러리(캣츠 이팩트) 사용하기  그럼 완전 함수는 뭔지 먼저 알아보겠습니다.\n완전 함수(Total Function) 완전 함수는 \u0026ldquo;모든 입력값에 대해 정의된 함수\u001c\u0026quot;라고 설명되어 있습니다. 완전 함수와 친한 관계인 부분 함수(Partial Function)와 함께 아주 상황을 가정해보면 아래 코드와 같습니다(프로그래밍에선 완전 함수와 부분 함수라는 표현을 사용). 다만, 수학에서 말하는 함수는 완전 함수를 칭합니다. 예를 들어 y = x 같은 함수가 있습니다.\n// 억지 스러운 예제인건 아량으로 넘어가주시고...  // Partial Function def divideP(a: Int, b: Int): String = s\u0026#34;Answer: ${a/b}\u0026#34; // Total Function def divideT(a: Int, b: Int): String = b match { case 0 =\u0026gt; \u0026#34;b must not be ZERO(0)!\u0026#34; case _ =\u0026gt; s\u0026#34;Answer: ${a/b}\u0026#34; } 차이는 한가지 입니다. \u0026ldquo;어떤 함수가 \u0026lsquo;가능한 입력\u0026rsquo;을 모두 다뤘느냐\u0026rdquo;. 그리고 비슷한 예로 Enum을 생각해보면 쉽습니다.\nenum State { Start, Progress, End } // ...  switch(state) { case Start: // do something  break; case Progress: // do something  break; case End: // do something  break; } // 혹은  switch(state) { case Progress: // do progress  break; default: // do nothing  break; } 에러 타입 사용 전 이런 식의 코드로 완전 함수를 표현할 수 있습니다. 하지만 종종 우리가 스위치 문을 다룰 땐 default 등은 빼놓기도 하고 if-else로 복잡한 코드가 구현되어 있을 때 구멍이 생기기도 하는 등(혹은 구멍이 생긴 논리의 흐름이 몽땅 else 부분을 통과한다든지\u0026hellip;) 신경을 써야 하는 부분이 존재합니다.\n그래서 위 스칼라 문서에서 소개하는 방법이 \u0026ldquo;Option(자바의 Optional과 비슷)이나 Either를 활용하자\u0026rdquo; 입니다. 이 내용을 듣기 전에 저는 아래와 같은 형식으로 완전 함수를 구현했는데요. 아래의 형식으로 구현해도 의미가 충분히 전달되는 경우 상관없지만, 그 외에는(else ㅋㅋ) 에러 타입을 사용하는 편이 훨씬 좋은 방법이라고 하셨습니다.\ntrait FeTrait case class FullAbc() extends FeTrait case class EmptyAbc() extends FeTrait def feFun(n: Int): FeTrait = { try { // 뚝딱뚝딱  FullAbc() } catch { case e: Exception =\u0026gt; EmptyAbc() } } 에러 타입 사용 후 Option, Either Option과 Either는 많이 사용하는 에러 타입입니다. Option의 경우 결과가 있는지 없는지를 표현할 때, Either는 내가 수행한 함수의 결과가 정상인지 비정상인지 나타내는 효율적인 타입입니다. 역시 자세한 설명과 코드를 확인 하실 수 있습니다. 아래 간략히 코드로 써보겠습니다.\n특정 맵의 임의의 키로 값을 찾는 경우에는 그 맵에 해당 키(값)가 없을 수 있기 때문에 Option으로 표현할 수 있습니다. 그리고 드라이버를 연결할 때 드라이버를 찾을 수 없어 에러가 발생하는 경우(Left)와 찾은 드라이버를 반환하는 정상인 경우(Right - 중의적 표현)로 표현할 수 있습니다.\n// 특정 맵의 특정 키로 값을 찾는 함수 def getFrom(map: Map[Int, String], key: Int): Option[String] = ??? // 드라이버 연결 def conn(from: String): Either[NotFound, Driver] = ??? 에러 타입을 사용한 완전 함수 결과적으로 처음 작성했던 feFunc 함수의 경우 에러 타입을 이용해 완전 함수로 수정하면 아래와 같이 사용할 수 있습니다.\n// 변경 전 def feFun(n: Int): FeTrait = { try { // 뚝딱뚝딱  FullAbc() } catch { case e: Exception =\u0026gt; EmptyAbc() } } // 변경 후 def feFunT(n: Int): Either[Exception, FeTrait] = { try { // 뚝딱뚝딱  Right(FullAbc()) } catch { case e: Exception =\u0026gt; Left(e) } } // 정상 결과 Either[Exception, FeTrait] = Right(FullAbc()) // 비정상 결과 Either[Exception, FeTrait] = Left(java.lang.ArithmeticException: / by zero) 위 코드처럼 에러 타입을 이용한 완전 함수를 작성한 경우 함수의 합성 등에서 좀 더 직관적으로 한쪽의 결과(Right or Left) 만 집중적으로 생각하고 다룰 수 있습니다. 그리고 캣츠를 사용한 코드도 이 링크에서 확인하실 수 있습니다. 코드를 더 읽기 쉽게 작성할 수 있도록 도와줬다고 생각됩니다.\n기타  읽어볼 거리:  스칼라 나잇 발표 - 실 세계의 캣츠 슬라이드 쉐어    "
            }
        
    ,
        
            {
                "ref": "https://freenice12.github.io/post/first/",
                "title": "첫 게시물",
                "section": "post",
                "date" : "2021.03.30",
                "body": "휴고(hugo)를 이용한 github 페이지 작성하기  본 게시물은 mac 환경에서 작성 되었습니다. placeholder($$)안의 내용은 직접 변경하셔야 합니다.\n 준비 hugo with brew $ brew install hugo github 먼저, github에 repository를 생성해야 합니다. github에 페이지를 노출하는게 목표이기 때문입니다.\n myblog:  ex) https://github.com/$yourrepo$/myblog 컨텐츠 저장용 저장소입니다.   .github.io:  ex) https://github.com/$yourrepo$/$yourrepo$.github.io 실제 블로그를 게시할 저장소입니다. 단, 이 저장소를 생성할 때 READEME.md 파일을 함께 생성(체크) 해주세요.  추후 블로그에 서브 모듈을 추가할 때 사소한 문제가 생길 수 있습니다.      테마 쇼핑 아래 사이트에서 테마를 먼저 골라보세요.\n https://themes.gohugo.io/  local 이제 내 컴퓨터에 블로그 포스팅을 위한 저장소를 클론하겠습니다.\n# 원하는 폴더로 이동 $ mkdir /path/to/myblog/root $ cd /path/to/myblog/root # 블로그 생성 $ hugo new site myblog $ cd myblog # 구조 확인 or ls $ ll 이제부터는 깃허브 저장소와 연동을 할 차례입니다.\n myblog 저장소 연결  https://github.com/$yourrepo$/myblog   publish 저장소 연결  https://github.com/$yourrepo$/$yourrepo$.github.io 이 저장소를 생성할 때 README.md 라도 만들어 두지 않으면 경고 문구를 만나게 됩니다!   쇼핑한 테마 저장소 연결  쇼핑한 저장소는 두 가지 방법중 택해서 연동합니다.  fork 한 후 연결 직접 연결 각 테마 메인 페이지 등을 살펴보시면 설정에 참고할 수 있도록 코드가 있습니다.      테마는 fork 한 후 연동하는 것을 추천합니다. 커스텀(저는 제외 ㅠㅠ)을 하든지 최신으로 동기화 하든지 먼저 내손을 거쳐야만 하기 때문에 좀 더 이점이 있습니다.\n# myblog 저장소 연결 $ git remote add origin https://github.com/$yourrepo$/blog.git # publish 할 저장소 연결 - 이름은 public 으로... $ git submodule add https://github.com/$yourrepo$/$yourrepo$.github.io.git public # 테마 연결 $ cd themes $ git submodule add https://github.com/$yourrepo$/\u0026lt;themename\u0026gt;.git \u0026lt;themename\u0026gt; 환경 설정 기본적인 준비는 마쳤습니다.\n이제 myblog 루트에 config.toml 파일을 수정합니다. 이 파일은 각 테마의 메인 페이지 등에 설정에 참고할 수 있는 코드가 있습니다.\n저의 경우에는 아래 설정을 가장 먼저 변경했습니다.\ntheme = \u0026quot;\u0026lt;themename\u0026gt;\u0026quot; baseurl = \u0026quot;https://$yourrepo$.github.io/\u0026quot; title = \u0026quot;\u0026lt;title\u0026gt;\u0026quot; 확인(local) 이제 내 컴퓨터에서 블로그를 직접 확인해봅니다. 자세한 내용은 휴고 홈 페이지(옵션 관련 페이지)를 확인합니다.\n먼저 게시글을 작성하고 확인해봅니다.\n# 게시글 생성 $ hugo new post/first.md # 게시글 작성 $ vim post/first.md # 게시글 확인 $ hugo server -D  localhost:1313 에서 확인할 수 있습니다. 위에서 게시글을 생성하면 최초에 draft(draft: true)로 생성되기 때문에 별다른 수정을 하지 않고 게시글 작성을 마쳤다면 \u0026lsquo;-D\u0026rsquo; 옵션을 통해 draft 게시글도 확인할 수 있게 실행해야 합니다.  공개! 저장소 최신화 드디어 내가 작성한 게시글을 공개합니다. 위에서 생성한 게시글의 draft를 삭제하거나 false 로 변경하면 게시글이 공개되는데, 이를 github를 통해서 공개하기 위해서는 우리가 수정하고 설정한 코드와 문서들을 github에 push 해야 합니다.\n 순서:  hugo 빌드 public(문서가 저장될 공개 저장소: $yourrepo$.github.io) 저장소에 빌드 결과물 push hugo 파일 등을 myblog 저장소에 push    # 빌드할 때 사용할 테마는 myblog/themes 하위 폴더를 참조합니다. $ hugo -t \u0026lt;themename\u0026gt; # public push $ cd public # ..../myblog/public $ git add . $ git commit -m \u0026#39;\u0026lt;message\u0026gt;\u0026#39; $ git push origin # 오류가 발생하는 경우 오류 메시지의 명령어를 실행하세요 ex) git push --set-upstream origin master # myblog push $ cd .. # ..../myblog $ git add . $ git commit -m \u0026#39;\u0026lt;message\u0026gt;\u0026#39; $ git push --set-upstream origin master 확인 이제 드디어 블로그를 확인할 시간입니다. 우리가 정한 페이지로 브라우저에서 접속해 봅니다.\n주소: $yourrepo$.github.io\n이제 페이지를 확인 후 즐겁게 하던일을 합니다!!\n저장소 최신화 (optional) 자동화 cli 명령 이어 붙이기  스크립트 사용하기 어려울 때 themename 과 message 만 수정해서 사용할 수 있습니다. 하지만 스크립트로 자동화 하는것을 추천합니다.\n # hugo 빌드 \u0026amp;\u0026amp; public push \u0026amp;\u0026amp; myblog push $ hugo -t \u0026lt;themename\u0026gt; \u0026amp;\u0026amp; cd public \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#39;\u0026lt;message\u0026gt;\u0026#39; \u0026amp;\u0026amp; git push origin --set-upstream origin master \u0026amp;\u0026amp; cd .. \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#39;\u0026lt;message\u0026gt;\u0026#39; \u0026amp;\u0026amp; git push --set-upstream origin master 쉘 스크립트를 이용한 자동화  블로그 루트 폴더(\u0026hellip;./myblob)에 publish.sh 파일 생성 후 실행할 수 있도록 권한을 변경\n #!/bin/bash  echo \u0026#34;=========\u0026#34; echo \u0026#34;publising\u0026#34; echo \u0026#34;=========\u0026#34; hugo -t harbor cd public git add . msg=\u0026#34;hugo build: `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push cd .. git add . msg=\u0026#34;published: `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push 번외: 테마를 수정했다면\u0026hellip;(optional) 테마를 수정한 경우 그리고 포크를 했다면 본인의 저장소에 push를 해주세요.\n끝! "
            }
        
    
]